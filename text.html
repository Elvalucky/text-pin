<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Adaptive AR Text Pin — WebXR Hit‑Test + AR.js Fallback</title>
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <!-- AR.js for A-Frame (marker fallback) -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#000}
    /* shared UI */
    #ui{position:fixed;left:0;right:0;bottom:0;background:rgba(0,0,0,.6);color:#fff;font:14px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;padding:10px 10px 12px;box-shadow:0 -8px 24px rgba(0,0,0,.25);z-index:10}
    #ui form{display:grid;grid-template-columns:1fr minmax(90px,210px) auto;gap:8px;align-items:end}
    #ui label{display:flex;flex-direction:column;font-size:12px;opacity:.95}
    #ui input{height:36px;border-radius:10px;border:1px solid rgba(255,255,255,.25);background:rgba(255,255,255,.1);color:#fff;padding:6px 10px}
    #ui button{height:36px;border:none;border-radius:10px;background:#4ad;font-weight:700;padding:0 16px;color:#002;cursor:pointer}
    #hint{position:fixed;top:8px;left:8px;background:rgba(0,0,0,.55);color:#fff;padding:8px 10px;border-radius:10px;font:13px system-ui;z-index:10}
    #mode-webxr, #mode-arjs{display:none}
    #startAR{position:fixed;top:12px;right:12px;z-index:11;background:#fff;color:#111;border:0;border-radius:12px;padding:10px 14px;font-weight:700}
  </style>
</head>
<body>
  <div id="hint">Detecting capabilities…</div>

  <!-- ======== MODE 1: WebXR Hit-Test (Android Chrome etc.) ======== -->
  <div id="mode-webxr">
    <button id="startAR">Start AR</button>
    <a-scene
      renderer="colorManagement:true; physicallyCorrectLights:true"
      xrweb=""  
      webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: #ui"
      vr-mode-ui="enabled:false"
      embedded>

      <a-entity light="type: ambient; intensity: 0.7"></a-entity>
      <a-entity light="type: directional; intensity: 0.8" position="0.5 1 0.5"></a-entity>

      <!-- Reticle (hit-test cursor) -->
      <a-entity id="reticle" visible="false" rotation="-90 0 0">
        <a-ring radius-inner="0.04" radius-outer="0.06" material="opacity:0.9"></a-ring>
        <a-entity position="0 0 0.001">
          <a-circle radius="0.004" material="opacity:0.9"></a-circle>
        </a-entity>
      </a-entity>

      <!-- The placed text entity in WebXR mode -->
      <a-entity id="text-webxr" text="value:; align:center; width:2; color:#FFD166" position="0 0 -1" visible="false"></a-entity>

      <a-entity camera></a-entity>
    </a-scene>
  </div>

  <!-- ======== MODE 2: AR.js Marker fallback (iOS Safari / desktop) ======== -->
  <div id="mode-arjs">
    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" renderer="colorManagement:true; physicallyCorrectLights:true" vr-mode-ui="enabled:false">
      <a-entity light="type: ambient; intensity: 0.6"></a-entity>
      <a-entity light="type: directional; intensity: 0.8" position="0.5 1 0.5"></a-entity>

      <!-- Marker: Hiro -->
      <a-marker id="marker-hiro" preset="hiro">
        <a-plane class="dropzone" width="2" height="2" rotation="-90 0 0" material="opacity:0; transparent:true"></a-plane>
        <a-entity id="text-hiro" text="value:; align:center; width:1.8; color:#90EE90" position="0 0 0" rotation="-90 0 0"></a-entity>
      </a-marker>

      <!-- Marker: Kanji -->
      <a-marker id="marker-kanji" preset="kanji">
        <a-plane class="dropzone" width="2" height="2" rotation="-90 0 0" material="opacity:0; transparent:true"></a-plane>
        <a-entity id="text-kanji" text="value:; align:center; width:1.8; color:#FFD166" position="0 0 0" rotation="-90 0 0"></a-entity>
      </a-marker>

      <!-- Raycaster for tap-to-place on marker planes -->
      <a-entity id="mouseCursor" cursor="rayOrigin: mouse" raycaster="objects: .dropzone; interval: 0"></a-entity>

      <a-entity camera></a-entity>
    </a-scene>
  </div>

  <!-- ======== Bottom UI (shared) ======== -->
  <div id="ui">
    <form id="form">
      <label>Text
        <input id="msg" placeholder="Type message…" maxlength="80" />
      </label>
      <label>Scale
        <input id="scale" value="1.0" />
      </label>
      <button type="submit">Confirm / Update</button>
    </form>
  </div>

  <script>
    // ---------- capability detection ----------
    async function supportsWebXRHitTest(){
      if(!('xr' in navigator)) return false;
      try{
        const ok = await navigator.xr.isSessionSupported('immersive-ar');
        return !!ok;
      }catch(e){return false}
    }

    const $hint = document.getElementById('hint');
    const $modeWebXR = document.getElementById('mode-webxr');
    const $modeARJS = document.getElementById('mode-arjs');

    (async ()=>{
      if (await supportsWebXRHitTest()){
        $modeWebXR.style.display = 'block';
        $hint.textContent = 'WebXR: 点地面放置（Android Chrome 最稳）。';
        initWebXR();
      } else {
        $modeARJS.style.display = 'block';
        $hint.textContent = 'AR.js: 对准 Hiro/Kanji 标记，然后点击标记平面放置。';
        initARJS();
      }
    })();

    // ---------- Shared UI state ----------
    const state = JSON.parse(localStorage.getItem('adaptive-ar-text')||'{}');
    function persist(){ localStorage.setItem('adaptive-ar-text', JSON.stringify(state)); }

    const $form = document.getElementById('form');
    const $msg = document.getElementById('msg');
    const $scale = document.getElementById('scale');

    // ---------- WebXR Hit-Test mode ----------
    function initWebXR(){
      const scene = document.querySelector('#mode-webxr a-scene');
      const reticle = document.getElementById('reticle');
      const text = document.getElementById('text-webxr');
      const startBtn = document.getElementById('startAR');

      let xrSession = null;
      let viewerSpace = null;
      let hitTestSource = null;

      startBtn.addEventListener('click', async ()=>{
        try{
          // Must be called on user gesture
          const session = await navigator.xr.requestSession('immersive-ar', {requiredFeatures:['hit-test','dom-overlay'], domOverlay: {root: document.body}});
          xrSession = session;
          scene.renderer.xr.setSession(session);

          const refSpace = await scene.renderer.xr.getReferenceSpace();
          viewerSpace = await session.requestReferenceSpace('viewer');
          hitTestSource = await session.requestHitTestSource({space: viewerSpace});

          session.addEventListener('end', ()=>{ xrSession=null; hitTestSource=null; viewerSpace=null; reticle.setAttribute('visible', 'false');});

          // Render loop hook to update reticle pose
          scene.renderer.xr.addEventListener('sessionstart', ()=>{ reticle.setAttribute('visible', 'false'); });

          scene.addEventListener('enter-vr', ()=>{ /* A-Frame enters AR */ });

          // On each frame, perform hit test
          scene.renderer.xr.setAnimationLoop((t, frame)=>{
            if(!frame) return;
            const referenceSpace = scene.renderer.xr.getReferenceSpace();
            const hits = frame.getHitTestResults(hitTestSource);
            if (hits.length > 0){
              const pose = hits[0].getPose(referenceSpace);
              reticle.object3D.visible = true;
              reticle.object3D.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
              // Orient reticle flat on surface
              const quat = pose.transform.orientation;
              reticle.object3D.quaternion.set(quat.x, quat.y, quat.z, quat.w);
              reticle.object3D.rotation.x = -Math.PI/2; // ensure flat ring
            } else {
              reticle.object3D.visible = false;
            }
          });
        } catch(err){
          console.error(err);
          alert('Failed to start AR session. Try Android Chrome.');
        }
      });

      // Place or update text at reticle on tap
      scene.addEventListener('click', ()=>{
        if (!reticle.object3D.visible) return;
        const p = reticle.object3D.position;
        text.setAttribute('position', `${p.x} ${p.y+0.01} ${p.z}`);
        text.setAttribute('visible', 'true');
        // Save last pos
        state.webxr = state.webxr || {};
        state.webxr.pos = [p.x, p.y+0.01, p.z];
        state.webxr.msg = state.webxr.msg || '';
        state.webxr.scale = state.webxr.scale || 1.0;
        persist();
      });

      // Restore previous placement if any
      if (state.webxr && state.webxr.pos){
        const [x,y,z] = state.webxr.pos;
        text.setAttribute('position', `${x} ${y} ${z}`);
        text.setAttribute('visible', 'true');
        if (state.webxr.msg) text.setAttribute('text', `value: ${state.webxr.msg}; align: center; width: 2; color: #FFD166`);
        if (state.webxr.scale) text.setAttribute('scale', `${state.webxr.scale} ${state.webxr.scale} ${state.webxr.scale}`);
      }

      // Form updates message/scale
      $form.addEventListener('submit', e=>{
        e.preventDefault();
        const msg = $msg.value || '';
        const sc = parseFloat($scale.value||'1')||1;
        text.setAttribute('text', `value: ${msg}; align: center; width: 2; color: #FFD166; wrapCount: 24`);
        text.setAttribute('scale', `${sc} ${sc} ${sc}`);
        state.webxr = state.webxr || {};
        state.webxr.msg = msg; state.webxr.scale = sc; persist();
      });
    }

    // ---------- AR.js Marker fallback mode ----------
    function initARJS(){
      const scene = document.querySelector('#mode-arjs a-scene');
      const cursor = document.querySelector('#mouseCursor');

      function findAncestorMarker(el){
        let p = el; while (p && p.tagName){ if (p.tagName.toLowerCase()==='a-marker') return p; p = p.parentEl; } return null;
      }

      function textEntityForMarkerId(mid){
        if (mid==='marker-hiro') return document.getElementById('text-hiro');
        if (mid==='marker-kanji') return document.getElementById('text-kanji');
        return null;
      }

      // tap to place on marker plane
      scene.addEventListener('click', ()=>{
        const rc = cursor.components.raycaster;
        if (!rc || !rc.intersections || rc.intersections.length===0) return;
        const hit = rc.intersections[0];
        const markerEl = findAncestorMarker(hit.object.el);
        if (!markerEl) return;
        const local = markerEl.object3D.worldToLocal(hit.point.clone());
        const t = textEntityForMarkerId(markerEl.id);
        if (!t) return;
        t.setAttribute('position', `${local.x} ${Math.max(local.y,0)} ${local.z}`);
        // persist per marker
        const key = (markerEl.id==='marker-hiro')?'hiro':'kanji';
        state[key] = state[key]||{};
        state[key].pos = [local.x, Math.max(local.y,0), local.z];
        state[key].msg = state[key].msg || '';
        state[key].scale = state[key].scale || 1.0;
        persist();
      });

      // restore
      ['hiro','kanji'].forEach(key=>{
        const t = document.getElementById(`text-${key}`);
        const s = state[key];
        if (!t || !s) return;
        if (s.pos){ const [x,y,z]=s.pos; t.setAttribute('position', `${x} ${y} ${z}`); }
        if (s.msg){ t.setAttribute('text', `value: ${s.msg}; align: center; width: 1.8; color: ${key==='hiro'?'#90EE90':'#FFD166'}; wrapCount: 24`); }
        if (s.scale){ t.setAttribute('scale', `${s.scale} ${s.scale} ${s.scale}`); }
      });

      // form updates currently visible marker text (choose last edited or default hiro)
      $form.addEventListener('submit', e=>{
        e.preventDefault();
        const msg = $msg.value || '';
        const sc = parseFloat($scale.value||'1')||1;
        // choose a default marker to update if none clicked yet
        let key = 'hiro';
        // if user last clicked kanji, prefer it
        if (state.__last==='kanji') key='kanji';
        const t = document.getElementById(`text-${key}`);
        if (t){
          t.setAttribute('text', `value: ${msg}; align: center; width: 1.8; color: ${key==='hiro'?'#90EE90':'#FFD166'}; wrapCount: 24`);
          t.setAttribute('scale', `${sc} ${sc} ${sc}`);
          state[key] = state[key] || {};
          state[key].msg = msg; state[key].scale = sc; persist();
        }
      });

      // track last clicked marker key for convenience
      scene.addEventListener('click', ()=>{
        const rc = cursor.components.raycaster;
        if (!rc || !rc.intersections || rc.intersections.length===0) return;
        const hit = rc.intersections[0];
        const markerEl = findAncestorMarker(hit.object.el);
        if (!markerEl) return;
        state.__last = (markerEl.id==='marker-hiro')?'hiro':'kanji';
        persist();
      });
    }
  </script>
</body>
</html>
